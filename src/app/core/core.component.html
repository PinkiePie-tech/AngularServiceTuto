<h1>Bienvenue dans ce petit tuto Observable</h1>

<div>
    Pour rappel, un observable est un typage provenant de rxjs, elle permet d'anticiper l'arrivée d'une valeur en préparant son traitement.
    Par exemple, on utilise les observables lors d'un appel réseau, d'une entrée utilisateur, d'un click sur un bouton. L'observabilité permet d'avoir des sites qui se réactualise au changement de valeur.
</div>
<br>
<div>
    Un observable peut se découper en 3 parties, la première est l'observable lui même, ce qui génère la donnée de base.
    Cette donnée de base peut être généré par plusieurs évènements comme cité plus haut, ça peut être un Observable comme une combinaison d'Observable
    Voici quelques exemples d'Observable
    <ul>
        <li>
            of("maValeur") va créer un observable contenant maValeur, très utilisé pour la création de mock ou dans des catchError
        </li>
        <li>
            timer(2000) va créer un observable qui va se déclencher au bout de 2000 ms, utilise pour créer des exercices comme ceux d'aujourd'hui, ou alors générer une fausse durée d'attente lors d'un mock pour simuler l'attente réseau ou une connexion en carton pate
        </li>
        <li>
            interval(2000) va créer un observable qui va se déclencher toutes les 2000 ms, utilise pour créer des exercices comme ceux d'aujourd'hui
        </li>
        <li>
            Les FormControl, particularité propre à Angular, permettront d'avoir des observables lié à des évènements sur les formulaires, facilitant ainsi la récupération des données
        </li>
        <li>
            httpService est un service qui va générer des Observable à partir d'un appel réseau, on retrouvera http.get, .post, .put, .delete dans la liste des appels possibles
        </li>
        <li>
            Les Subjects, le plus commun étant le BehaviorSubject, il permet de créer un observable qui pourra être déclenché via le code et non une action extérieur. On le rattachera souvent à des évènements extérieurs n'ayant pas de concept d'observabilité ( un clic ou un système de refresh de donnée )
        </li>
    </ul>
    <br>
    La deuxième partie est la partie souscription, cette partie permet d'activer l'Observable. Un observable peut être créé mais peut être souscris à un autre moment, ce moment est décidé lors de la subscription.
    Il y a deux manières de souscrire à un Observable.
    <br>
    La première est via un .subscribe((maValeur) =&gt; &#123; //mon traitement typescript &#125;), le subscribe permettra de récupérer la valeur contenu dans l'Observable et d'effectuer l'action que l'on souhaite avec cette valeur.
    Dans la plupart des cas, le subscribe est utilisé lors des appels POST, PUT ou DELETE, la plupart des souscriptions doivent se faire via la vue html, cela évite la gestion des souscription
    <br>
    Mais c'est quoi la gestion des souscriptions, lors d'une souscription à un observable, on se retrouve avec une action qui se déclenche avec un évènement, mais si on change de page par exemple, l'observable lui continue de déclencher ses évènements, on peut donc se retrouver avec une action qui persiste alors que la page a été quittée.
    Ce genre de soucis peut causer des problèmes mémoire, voir des appels intensifs au niveau du réseau. pour éviter cela, on déclare au début de son composant une variable qui va receuillir les souscriptions qui sera de type Subscription, sous la forme "private subs = new Subscription()"
    Une fois déclaré, si un subscribe se retrouve dans le code, on engobera le subscribe avec un add, donnant ce genre de code "this.subs.add(of("maValeur").subscribe(maValeur =&gt; &#123; // mon code TS &#125;))"
    On rajoutera aussi une méthode ngOnDestroy où on se désabonnera des souscriptions effectuées, avec un this.subs.unsubscribe()
    Les subscribes sont souvent utilisés pour des évènements comme POST, PUT ou DELETE, ses évènements étant des one shoot, on utilisera un opérateur nommé "take(1)", cette opérateur se situera dans le pipe et permettra de souscrire une fois et ensuite de s'auto-unsubscribe, évitant ainsi la partie gestion des souscriptions
    <br>
    C'est pourquoi il est intéressant de subscribe via la vue html, un simple "| async" permettra de gérer le subscribe et la partie unsubscribe sans créer de nouvelles fonctions
    Pour rappel, chaque souscription déclenchera les évènements, si l'Observable est par exemple un appel réseau, si 15 | async
    <br>
    <br>
    La dernière partie est la transformation, alors la c'est la fête, on peut changer du tout au tout la donnée, pour cela, on va utiliser des opérateurs rxjs, une bibliothèque typescript bien pratique pour notre cas ^^
    il existe moulte opérateur mais certain sont redondant. pour modifier la valeur des Observables avant qu'on atteigne le subscribe, on va utiler la méthode pipe avec ses opérateurs, cela permet de transformer la donnée, créer des effets de bord, etc...
    <ul>
        <li>
            Opérateur "map" : le plus utilisé, il permet de <b>transformer une donnée</b> d'un type A vers une donnée de type B, il prend en paramètre un callback avec un paramètre de type A, la valeur retournée dans le callback sera de type B
        </li>
        <li>
            Opérateur "tap" : il permet de faire des actions à partir de la donnée de type A, mais il n'impactera jamais la donnée, il prend en paramètre un callback avec un paramètre de type A, <b>il ne renvoie rien</b>, l'opérateur suivant le tap prendra la valeur de type A
        </li>
        <li>
            Opérateur "filter" : il permet de filtrer les events, permettant ainsi d'éviter des valeurs qui pourraient nuire à l'application ( undefined, null, etc... ), il prend en paramètre un callback avec un paramètre de type A, <b>la valeur retournée dans le callback devra être de type booléen</b>
        </li>
        <li>
            Opérateur "switchMap" : il permet de passer d'un Observable de type A vers un Observable de type B, il prend en paramètre un callback avec un paramètre de type A, la valeur retournée dans le callback sera <b>obligatoirement un Observable</b> de type B
        </li>
    </ul>
    Il existe d'autre opérateur permettant de gérer les évènements plus que la donnée, ses opérateurs sont indépendant de la valeur
    <ul>
        <li>
            Opérateur "take(1)" : l'opérateur take prend en paramètre un nombre, c'est le nombre d'itération sur lequel l'observable va se déclencher, une fois ce nombre atteint, la souscription se termine automatiquement 
        </li>
        <li>
            Opérateur "debounceTime(200)": cet opérateur permet d'attendre le nombre de milliseconde donnée en paramètre, cet opérateur est utilisé dans la saisie clavier, permettant ainsi de ne pas déclencher à chaque lettre par exemple
        </li>
        <li>
            Opérateur "shareReplay(&#123;refCount: true, bufferSize: 1&#125;)": cet opérateur permet de partager le résultat entre toutes les souscriptions, pour un observable lié à un appel réseau, cela évite d'aller 15 fois l'url si on a 15 souscription, le résultat est partager à toutes les souscriptions
        </li>
        <li>
            Opérateur "distinctUntilChanged()": cet opérateur filtre les évènements, si les valeurs précédentes et actuelles sont les mêmes, rien ne se déclenche, cela permet ici d'éviter des appels qui pourrait être redondant ( genre deux fois la même recherche de suite )
        </li>
        <li>
            Opérateur "startWith()": l'opérateur startWith prend en paramètre un type A, ce type doit être identique à l'étape précédente, le premier event sur cette observable sera la valeur dans le StartWith, idéal pour les valueChanges pour les formulaires ou on utilisera this.formControl.getRawValue()
        </li>
    </ul>
</div>

